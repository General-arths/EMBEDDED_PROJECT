#include "stm32f4xx_hal.h"
#include "board_pins.h"
#include "isr_latency.h"
#include "dwt_cycle.h"
#include "softsched.h"
#include "workload.h"

// --- extern handles generated by CubeMX (.ioc) ---
extern UART_HandleTypeDef huart2;
extern DMA_HandleTypeDef  hdma_usart2_rx;
extern TIM_HandleTypeDef  htim1;
extern TIM_HandleTypeDef  htim6;

// Forward decls for auto-gen init (CubeMX provides these)
void SystemClock_Config(void);
void MX_GPIO_Init(void);
void MX_DMA_Init(void);
void MX_USART2_UART_Init(void);
void MX_TIM1_Init(void);
void MX_TIM6_Init(void);

// RX buffer for USART2 DMA (circular)
#define UART_RX_BUF_SZ 256
static uint8_t uart_rx_buf[UART_RX_BUF_SZ];

static inline void NVIC_Config(void) {
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);  // all preempt bits
  HAL_NVIC_SetPriority(TIM1_UP_TIM10_IRQn, 0, 0);      // Highest
  HAL_NVIC_SetPriority(DMA1_Stream5_IRQn,  1, 0);      // USART2 RX DMA (if you enabled its IRQ; not needed for circular idle)
  HAL_NVIC_SetPriority(USART2_IRQn,        2, 0);      // Medium
  HAL_NVIC_SetPriority(TIM6_DAC_IRQn,     14, 0);      // Low
  HAL_NVIC_SetPriority(PendSV_IRQn,       15, 0);      // Lowest
}

int main(void)
{
  HAL_Init();
  SystemClock_Config();
  MX_GPIO_Init();
  MX_DMA_Init();
  MX_USART2_UART_Init();
  MX_TIM1_Init();
  MX_TIM6_Init();

  DWT_CycleCounterInit();
  SoftSched_Init();
  NVIC_Config();

  // Start timers (update IRQs enabled via MX_ init)
  HAL_TIM_Base_Start_IT(&htim1); // 20 kHz
  HAL_TIM_Base_Start_IT(&htim6); // 1 kHz

  // Start UART2 RX DMA (circular) and enable IDLE interrupt
  HAL_UART_Receive_DMA(&huart2, uart_rx_buf, UART_RX_BUF_SZ);
  __HAL_UART_ENABLE_IT(&huart2, UART_IT_IDLE);

  // (Optional) Disable SysTick for tickless baseline measurements:
  // SysTick->CTRL = 0;

  while (1) {
    __WFI(); // sleep until an interrupt
  }
}

/* ------------------ IRQ HANDLERS ------------------ */

void TIM1_UP_TIM10_IRQHandler(void)
{
  if (__HAL_TIM_GET_FLAG(&htim1, TIM_FLAG_UPDATE) && __HAL_TIM_GET_IT_SOURCE(&htim1, TIM_IT_UPDATE)) {
    LAT_HIGH(); // first instruction for latency pulse
    __HAL_TIM_CLEAR_IT(&htim1, TIM_IT_UPDATE);

    // Post high-priority control tick work
    SoftSched_PostFromISR(SCHED_HIGH, w_ctrl_tick, 0);

    LAT_LOW();
  }
}

// USART2 IDLE-line detection for "end of frame" with circular DMA
void USART2_IRQHandler(void)
{
  LAT_HIGH();

  if (__HAL_UART_GET_FLAG(&huart2, UART_FLAG_IDLE) != RESET) {
    __HAL_UART_CLEAR_IDLEFLAG(&huart2);

    // OPTIONAL: compute received length (how many bytes since last check)
    // uint16_t remaining = __HAL_DMA_GET_COUNTER(&hdma_usart2_rx);
    // uint16_t received  = UART_RX_BUF_SZ - remaining; // roll your own reader

    SoftSched_PostFromISR(SCHED_MED, w_uart_rx_frame, 0);
  }

  // Handle other UART flags only if used (RXNE not needed with DMA)
  LAT_LOW();
}

// TIM6: low-priority housekeeping tick
void TIM6_DAC_IRQHandler(void)
{
  if (__HAL_TIM_GET_FLAG(&htim6, TIM_FLAG_UPDATE) && __HAL_TIM_GET_IT_SOURCE(&htim6, TIM_IT_UPDATE)) {
    __HAL_TIM_CLEAR_IT(&htim6, TIM_IT_UPDATE);
    SoftSched_PostFromISR(SCHED_LOW, w_log_flush, 0);
  }
}

/* --------------- CubeMX-generated MSP init --------------- */
/* Ensure MX_GPIO_Init configures PA5 as Output push-pull, Very High speed.
   Ensure MX_USART2_UART_Init sets 115200 8N1, and MX_DMA_Init configures
   DMA1_Stream5 Channel 4 for USART2_RX in Circular mode.
   Ensure the timer base init sets periods to hit ~20 kHz (TIM1) and 1 kHz (TIM6). */

